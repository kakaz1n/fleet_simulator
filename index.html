<!DOCTYPE html>
<html lang="pt">

<head>
    <meta charset="UTF-8">
    <title>Gerenciador de Rob√¥s e Produ√ß√£o de Tratores</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.1.3/css/bootstrap.min.css">
    <!-- Font Awesome para √≠cones -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
        integrity="sha512-Fo3rlrZj/kTcOnQyD/1eH+0FbF3jrLLj5V6F4Hl5k5b7CUemwS5bG0h4EGJ5xJcHJ8Yrw5h+Y+Sz71DkIp5GrA=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        .production-step {
            margin-bottom: 10px;
        }
    </style>
    <style>
        .chart-container {
            width: 100%;
            height: 300px;
            /* Define um tamanho fixo para os gr√°ficos */
            position: relative;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
        }
    </style>

</head>

<body class="container-fluid p-0" style="height: 100vh;">
    <h1 class="text-center">Gerenciador de Rob√¥s e Produ√ß√£o de Tratores</h1>
    <div class="row" style="min-height: 100vh;">
        <!-- Coluna da esquerda: A√ß√µes de rob√¥ e cria√ß√£o de trator -->
        <div class="col-md-3" style="padding-left: 3%;">
            <h3>Adicionar Rob√¥</h3>
            <input id="robot_name" type="text" class="form-control" placeholder="Nome do Rob√¥">
            <input id="robot_x" type="number" class="form-control mt-2" placeholder="Posi√ß√£o X">
            <input id="robot_y" type="number" class="form-control mt-2" placeholder="Posi√ß√£o Y">
            <button id="add_robot_button" class="btn btn-primary mt-2" onclick="addRobot()">Adicionar</button>

            <h3 class="mt-4">Solicitar Miss√£o de Entrega</h3>
            <label for="robot_select" class="mt-2">Selecione o Rob√¥</label>
            <select id="robot_select" class="form-control mt-1"></select>
            <label for="pickup_select">√Årea de Pick-up (Armaz√©m)</label>
            <select id="pickup_select" class="form-control mt-1"></select>
            <label for="delivery_select">√Årea de Entrega (C√©lula)</label>
            <select id="delivery_select" class="form-control mt-1"></select>
            <label for="items_text" class="mt-2">Itens (separados por v√≠rgula)</label>
            <input id="items_text" type="text" class="form-control mt-1" placeholder="ex: peca5, peca6">
            <button class="btn btn-success mt-2" onclick="handleDeliveryMission()">Solicitar Miss√£o</button>

            <!-- Se√ß√£o: Cria√ß√£o de Trator -->
            <h3 class="mt-4">Criar Trator</h3>
            <input id="tractor_id" type="text" class="form-control" placeholder="Nome do Trator">
            <div id="production_steps" class="mt-2">
                <!-- Primeira etapa -->
                <div class="production-step row">
                    <div class="col-6">
                        <select class="cell_select form-control">
                            <!-- Op√ß√µes ser√£o populadas com as c√©lulas -->
                        </select>
                    </div>
                    <div class="col-4">
                        <input type="text" class="kit_input form-control" placeholder="Kits (ex: peca1, peca2)">
                    </div>
                    <div class="col-2">
                        <button class="btn btn-danger remove_step" onclick="removeStep(this)"><i
                                class="fas fa-times"></i></button>
                    </div>
                </div>
            </div>
            <button class="btn btn-secondary mt-2" id="add_step">Adicionar Etapa</button>
            <button class="btn btn-primary mt-2" id="create_tractor">Criar Trator</button>
        </div>

        <!-- Coluna central: Mapa e Gerenciamento + Status de Produ√ß√£o de Tratores -->
        <div class="col-md-6">
            <div style="height:600px; overflow:hidden;">
                <canvas id="robotMap" style="width:100%; height:100%;"></canvas>
            </div>
            <div id="cells_panel">

            </div>
            <div class="container mt-4">
                <h3 class="text-center">üìä Distribui√ß√£o de Tempo por Estado</h3>

                <!-- Gr√°ficos Gerais -->
                <div class="row">
                    <div class="col-md-4">
                        <h4 class="text-center">C√©lulas (Geral)</h4>
                        <div class="chart-container"><canvas id="graficoCelulasGeral"></canvas></div>
                    </div>
                    <div class="col-md-4">
                        <h4 class="text-center">Rob√¥s (Geral)</h4>
                        <div class="chart-container"><canvas id="graficoRobosGeral"></canvas></div>
                    </div>
                    <div class="col-md-4">
                        <h4 class="text-center">Tratores (Geral)</h4>
                        <div class="chart-container"><canvas id="graficoTratoresGeral"></canvas></div>
                    </div>
                </div>
            </div>



            <h1 class="mt-3">Linha do Tempo (Timeline) - Exemplo</h1>

            <!-- BOT√ïES E SLIDER -->
            <div class="mt-3">
                <button id="btnTempoReal" class="btn btn-success">üîÑ Tempo Real</button>
                <button id="btnCarregarHistorico" class="btn btn-secondary">üìú Carregar Hist√≥rico</button>
                <button id="btnPlay" class="btn btn-primary">‚ñ∂Ô∏è Play</button>
                <button id="btnPause" class="btn btn-warning">‚è∏Ô∏è Pause</button>
                <input type="range" id="timelineSlider" min="0" max="0" value="0" step="1" style="width:400px;">
                <span id="sliderValue">0</span>
            </div>


            <div id="tractor_panel" class="border p-2 mt-2">
                <h4>Gerenciar e Visualizar Produ√ß√£o dos Tratores</h4>
                <ul id="tractor_ul" class="list-group"></ul>
            </div>
        </div>

        <!-- Coluna da direita: Status dos Rob√¥s e Pe√ßas -->
        <div class="col-md-3" style="padding-right: 1%;">
            <h3 class="mt-4">Status de Todos os Rob√¥s</h3>
            <div id="all_robots_details" class="border p-2"></div>
            <h3 class="mt-4">Status das Pe√ßas</h3>
            <div id="pieces_status" class="border p-2"></div>
            <div id="mir_status_panel" class="card mt-4">
                <div class="card-header bg-primary text-white">
                    <h4 id="mir_name">MIR - Carregando...</h4>
                </div>
                <div class="card-body">
                    <p id="mir_mission"><strong>Miss√£o:</strong> Carregando...</p>
                    <p id="mir_battery"><strong>Bateria:</strong> Carregando...</p>
                    <p id="mir_state"><strong>Estado:</strong> Carregando...</p>
                    <p id="mir_mode"><strong>Modo:</strong> Carregando...</p>
                    <p id="mir_position"> <strong>Posi√ß√£o:</strong> Carregando... </p>
                    <p id="mir_orientation"><strong>Orienta√ß√£o:</strong> Carregando...</p>
                    <p id="mir_path"><strong>Caminho:</strong> Carregando...</p>

                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Edi√ß√£o de Trator -->
    <div class="modal fade" id="editTractorModal" tabindex="-1" aria-labelledby="editTractorModalLabel"
        aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <form id="editTractorForm">
                    <div class="modal-header">
                        <h5 class="modal-title" id="editTractorModalLabel">Editar Trator</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
                    </div>
                    <div class="modal-body">
                        <input type="hidden" id="editTractorId">
                        <div id="editTractorSteps"></div>
                        <button type="button" class="btn btn-secondary mt-2" id="addEditStep">Adicionar Etapa</button>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                        <button type="submit" class="btn btn-primary">Salvar Altera√ß√µes</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    <div id="notifications-container" style="position: fixed; top: 20px; right: 20px; z-index: 10000;"></div>
    <script>
        let ws;

        function connectWebSocket() {
            ws = new WebSocket("ws://127.0.0.1:8000/ws");

            ws.onopen = function () {
                console.log("üîå Conectado ao WebSocket!");
            };

            ws.onmessage = function (event) {
                showToast(event.data);
            };

            ws.onclose = function () {
                console.log("‚ö†Ô∏è Conex√£o WebSocket fechada. Tentando reconectar...");
                setTimeout(connectWebSocket, 3000); // Tenta reconectar ap√≥s 3 segundos
            };

            ws.onerror = function (error) {
                console.log("‚ùå Erro no WebSocket:", error);
                ws.close(); // Fecha a conex√£o em caso de erro
            };
        }

        function showToast(message) {
            const container = document.getElementById("notifications-container");

            // Criando o elemento da notifica√ß√£o
            const toast = document.createElement("div");
            toast.classList.add("toast", "fade-in", "bg-dark", "text-white", "p-3", "mb-2", "rounded", "shadow");
            toast.style.minWidth = "280px";
            toast.style.position = "relative";
            toast.style.display = "flex";
            toast.style.alignItems = "center";
            toast.style.gap = "10px";
            toast.style.borderLeft = "5px solid #0d6efd"; // Azul destaque

            // √çcone da notifica√ß√£o
            const icon = document.createElement("i");
            icon.classList.add("fas", "fa-bell");
            icon.style.color = "#ffc107"; // Amarelo para destaque
            icon.style.fontSize = "20px";

            // Conte√∫do da notifica√ß√£o
            const textContainer = document.createElement("div");
            textContainer.innerHTML = `<strong>Notifica√ß√£o</strong><br>${message}`;

            // Barra de progresso
            const progress = document.createElement("div");
            progress.classList.add("toast-progress");
            progress.style.position = "absolute";
            progress.style.bottom = "0";
            progress.style.left = "0";
            progress.style.width = "100%";
            progress.style.height = "4px";
            progress.style.backgroundColor = "#0d6efd";
            progress.style.transition = "width 4s linear";

            // Adicionando os elementos na notifica√ß√£o
            toast.appendChild(icon);
            toast.appendChild(textContainer);
            toast.appendChild(progress);

            container.appendChild(toast);

            // Inicia a anima√ß√£o da barra de progresso
            setTimeout(() => {
                progress.style.width = "0";
            }, 50);

            // Remove a notifica√ß√£o ap√≥s 4 segundos com efeito de fade-out
            setTimeout(() => {
                toast.classList.add("fade-out");
                setTimeout(() => container.removeChild(toast), 500);
            }, 4000);
        }


        // Inicia o WebSocket
        connectWebSocket();
    </script>


    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.0"></script>

    <script>
        const API_URL = "http://127.0.0.1:8000";
        let currentFrame = 0;
        let robotChart;
        let robotsData = {};
        let walls = [];
        let areas = [];  // lista de √°reas (c√©lulas)

        // Plugin para desenhar labels personalizados no Chart.js
        const customLabelsPlugin = {
            id: "customLabels",
            beforeDraw(chart) {
                const ctx = chart.ctx;
                ctx.save();
                const labelConfigs = chart.options.plugins.customLabels;
                if (!labelConfigs || !labelConfigs.labels) return;
                labelConfigs.labels.forEach(label => {
                    const x = chart.scales.x.getPixelForValue(label.x);
                    const y = chart.scales.y.getPixelForValue(label.y);
                    ctx.font = "12px Arial";
                    ctx.fillStyle = "black";
                    ctx.textAlign = "center";
                    ctx.fillText(label.text, x, y);
                });
                ctx.restore();
            }
        };

        function createChart() {
            const ctx = document.getElementById('robotMap').getContext('2d');
            Chart.register(customLabelsPlugin);

            robotChart = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: [] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    elements: { line: { tension: 0 } },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            min: -100,  // Valor inicial do eixo X
                            max: 100,   // Valor inicial do eixo X
                        },
                        y: {
                            min: -120,  // Valor inicial do eixo Y
                            max: 120,   // Valor inicial do eixo Y
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        customLabels: { labels: [] },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: "xy",  // Permite mover horizontal e verticalmente
                                modifierKey: null, // ‚ùå Remove necessidade de segurar "Ctrl" para mover
                                overScaleMode: "xy", // Permite pan mesmo quando est√° com zoom
                                threshold: 10 // Suaviza a movimenta√ß√£o ao arrastar
                            },
                            zoom: {
                                wheel: {
                                    enabled: true, // Habilita zoom pelo scroll do mouse
                                },
                                pinch: {
                                    enabled: true // Habilita zoom por pin√ßa em touchscreen
                                },
                                mode: "xy" // Permite zoom em ambos os eixos
                            }
                        }
                    }
                }
            });
        }

        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let offsetX = 0;
        let offsetY = 0;

        const canvas = document.getElementById('robotMap');

        // üìå Evento ao pressionar o bot√£o esquerdo do mouse
        canvas.addEventListener("mousedown", function (event) {
            if (event.button === 0) { // 0 = Bot√£o esquerdo do mouse
                isDragging = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        });

        // üìå Evento ao mover o mouse
        canvas.addEventListener("mousemove", function (event) {
            if (!isDragging) return;

            const deltaX = (event.clientX - lastMouseX) * 0.05; // Sensibilidade do movimento
            const deltaY = (event.clientY - lastMouseY) * 0.05;

            lastMouseX = event.clientX;
            lastMouseY = event.clientY;

            // Ajusta os limites do gr√°fico ao arrastar
            robotChart.options.scales.x.min -= deltaX;
            robotChart.options.scales.x.max -= deltaX;
            robotChart.options.scales.y.min -= deltaY;
            robotChart.options.scales.y.max -= deltaY;

            robotChart.update("none"); // Atualiza sem anima√ß√£o para evitar flickering
        });

        // üìå Evento ao soltar o bot√£o do mouse
        canvas.addEventListener("mouseup", function () {
            isDragging = false;
        });

        // üìå Evento para evitar que o movimento continue se o mouse sair do canvas
        canvas.addEventListener("mouseleave", function () {
            isDragging = false;
        });


        async function loadMapData() {
            try {
                const res = await axios.get(`${API_URL}/status`);
                walls = res.data.walls || [];
                areas = res.data.areas || [];
                const doors = res.data.doors || [];
                // drawWalls();
                drawAreas(areas);
                drawDoors(doors);
                populateAreasSelects(areas);
                populateCellSelects(areas); // Preenche o select das c√©lulas no formul√°rio de trator
            } catch (error) {
                console.error("Erro ao carregar dados do mapa:", error);
            }
        }

        // function drawWalls() {
        //     let wallDataset = {
        //         label: "Paredes", data: walls.map(p => ({ x: p[0], y: p[1] })),
        //         backgroundColor: "black",
        //         borderColor: "black",
        //         borderWidth: 2, pointRadius: 4
        //     };
        //     robotChart.data.datasets.push(wallDataset);
        //     robotChart.update();
        // }

        // Atualiza o desenho das √°reas com a cor da borda definida
        let lastStatusCount = { complete: 0, pending: 0, noPiece: 0 };

        function drawAreas(areas) {
            // console.log("üîÑ Desenhando √°reas no mapa...");
            // console.log("üìå √Åreas recebidas:", areas);

            // Remove os datasets que representam as √°reas (identificados pela flag isArea)
            robotChart.data.datasets = robotChart.data.datasets.filter(ds => !ds.isArea);
            // Limpa os labels existentes do plugin customLabels
            robotChart.options.plugins.customLabels.labels = [];

            let statusCount = { complete: 0, pending: 0, noPiece: 0 };

            areas.forEach(area => {
                const { x1, y1, x2, y2, name } = area;

                let borderColor;
                let status = cellsStatus[name] || "noPiece"; // Se n√£o existir, assume "noPiece"

                if (status === "complete") {
                    borderColor = "green";
                } else if (status === "pending") {
                    borderColor = "red";
                } else {
                    borderColor = "yellow";
                }

                statusCount[status]++; // Contabiliza o status

                // Adiciona o dataset da c√©lula com a flag isArea para identifica√ß√£o
                robotChart.data.datasets.push({
                    isArea: true,
                    label: name,
                    data: [
                        { x: x1, y: y1 }, { x: x2, y: y1 },
                        { x: x2, y: y2 }, { x: x1, y: y2 },
                        { x: x1, y: y1 }
                    ],
                    borderColor: borderColor,
                    backgroundColor: "rgba(100, 100, 250, 0.2)",
                    borderWidth: 2,
                    showLine: true,
                    fill: true
                });

                // Adiciona um r√≥tulo central com o nome da c√©lula
                let centerX = (x1 + x2) / 2;
                let centerY = (y1 + y2) / 2;
                robotChart.options.plugins.customLabels.labels.push({
                    x: centerX,
                    y: centerY,
                    text: name,
                    color: "black"
                });
            });

            // ‚úÖ S√≥ atualiza o painel se os valores mudaram
            if (
                lastStatusCount.complete !== statusCount.complete ||
                lastStatusCount.pending !== statusCount.pending ||
                lastStatusCount.noPiece !== statusCount.noPiece
            ) {
                document.getElementById("cells_panel").innerHTML = `
    <div class="row justify-content-center" style="padding: 10px; border-radius: 8px; background: #f8f9fa; box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.1);">
        <div class="col-md-4 text-center">
            <h5 style="color: green; font-weight: bold;">‚úÖ Completas</h5>
            <p style="font-size: 20px;">${statusCount.complete}</p>
        </div>
        <div class="col-md-4 text-center">
            <h5 style="color: red; font-weight: bold;">‚ö†Ô∏è Pendentes</h5>
            <p style="font-size: 20px;">${statusCount.pending}</p>
        </div>
        <div class="col-md-4 text-center">
            <h5 style="color: orange; font-weight: bold;">üü° Ociosas</h5>
            <p style="font-size: 20px;">${statusCount.noPiece}</p>
        </div>
    </div>`;

                // Salva o √∫ltimo estado para compara√ß√£o futura
                lastStatusCount = { ...statusCount };
            }

            // Atualiza o gr√°fico
            robotChart.update("none");
        }

        function drawAreasHistorico(areas, cellsStatusTmp) {
            console.log("üîÑ Desenhando √°reas no mapa...");
            console.log("üìå √Åreas recebidas:", areas);

            // Remove os datasets que representam as √°reas (identificados pela flag isArea)
            robotChart.data.datasets = robotChart.data.datasets.filter(ds => !ds.isArea);
            // Limpa os labels existentes do plugin customLabels
            robotChart.options.plugins.customLabels.labels = [];

            let statusCount = { complete: 0, pending: 0, noPiece: 0 };

            areas.forEach(area => {
                const { x1, y1, x2, y2, name } = area;

                let borderColor;
                let status = cellsStatusTmp[name] || "noPiece"; // Se n√£o existir, assume "noPiece"

                if (status === "complete") {
                    borderColor = "green";
                } else if (status === "pending") {
                    borderColor = "red";
                } else {
                    borderColor = "yellow";
                }

                statusCount[status]++; // Contabiliza o status

                // Adiciona o dataset da c√©lula com a flag isArea para identifica√ß√£o
                robotChart.data.datasets.push({
                    isArea: true,
                    label: name,
                    data: [
                        { x: x1, y: y1 }, { x: x2, y: y1 },
                        { x: x2, y: y2 }, { x: x1, y: y2 },
                        { x: x1, y: y1 }
                    ],
                    borderColor: borderColor,
                    backgroundColor: "rgba(100, 100, 250, 0.2)",
                    borderWidth: 2,
                    showLine: true,
                    fill: true
                });

                // Adiciona um r√≥tulo central com o nome da c√©lula
                let centerX = (x1 + x2) / 2;
                let centerY = (y1 + y2) / 2;
                robotChart.options.plugins.customLabels.labels.push({
                    x: centerX,
                    y: centerY,
                    text: name,
                    color: "black"
                });
            });

            // ‚úÖ S√≥ atualiza o painel se os valores mudaram
            if (
                lastStatusCount.complete !== statusCount.complete ||
                lastStatusCount.pending !== statusCount.pending ||
                lastStatusCount.noPiece !== statusCount.noPiece
            ) {
                document.getElementById("cells_panel").innerHTML = `
            <div style="padding: 10px; border-radius: 8px; background: #f8f9fa; box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.1);">
                <h4 style="text-align: center; margin-bottom: 10px;">Status dos Postos de trabalho</h4>
                <p style="color: green; font-weight: bold;"><strong>‚úÖ Completas:</strong> ${statusCount.complete}</p>
                <p style="color: red; font-weight: bold;"><strong>‚ö†Ô∏è Pendentes:</strong> ${statusCount.pending}</p>
                <p style="color: orange; font-weight: bold;"><strong>üü° Ociosas:</strong> ${statusCount.noPiece}</p>
            </div>`;

                // Salva o √∫ltimo estado para compara√ß√£o futura
                lastStatusCount = { ...statusCount };
            }

            // Atualiza o gr√°fico
            robotChart.update("none");
        }





        function drawDoors(doors) {
            doors.forEach(door => {
                robotChart.data.datasets.push({
                    label: "Porta",
                    data: [{ x: door[0], y: door[1] }],
                    backgroundColor: "green",
                    borderColor: "black",
                    borderWidth: 2,
                    pointRadius: 5
                });
            });
            robotChart.update();
        }

        function populateAreasSelects(areas) {
            const pickupSelect = document.getElementById("pickup_select");
            const deliverySelect = document.getElementById("delivery_select");
            pickupSelect.innerHTML = "";
            deliverySelect.innerHTML = "";
            areas.forEach(area => {
                let optionPickup = document.createElement("option");
                optionPickup.value = area.name;
                optionPickup.textContent = area.name;
                pickupSelect.appendChild(optionPickup);
                let optionDelivery = document.createElement("option");
                optionDelivery.value = area.name;
                optionDelivery.textContent = area.name;
                deliverySelect.appendChild(optionDelivery);
            });
        }

        // Preenche os selects de c√©lulas do formul√°rio de produ√ß√£o de trator
        function populateCellSelects(areas) {
            const cellSelects = document.getElementsByClassName("cell_select");
            Array.from(cellSelects).forEach(select => {
                select.innerHTML = "";
                areas.forEach(area => {
                    let option = document.createElement("option");
                    option.value = area.name;
                    option.textContent = area.name;
                    select.appendChild(option);
                });
            });
        }

        async function updateRobots() {
            try {
                const res = await axios.get(`${API_URL}/status`);
                robotsData = res.data.robots || {};

                updateRobotSelect();
                redrawRobotsOnChart();
                showAllRobotsDetails();
                updateMir();

            } catch (error) {
                console.error("Erro ao atualizar rob√¥s:", error);
            }
        }

        function updateRobotSelect() {
            const select = document.getElementById("robot_select");
            select.innerHTML = "<option value=''>Selecione um rob√¥ (opcional)</option>";
            for (const robotId in robotsData) {
                let busy = robotsData[robotId].current_delivery;
                let busyText = busy ? " (Em miss√£o)" : "";
                let option = document.createElement("option");
                option.value = robotId;
                option.textContent = robotId + busyText;
                if (busy) { option.style.color = "red"; }
                select.appendChild(option);
            }
        }

        let updateInProgress = false;
        function redrawRobotsOnChart() {
            if (updateInProgress) return;
            updateInProgress = true;
            setTimeout(() => {
                robotChart.data.datasets = robotChart.data.datasets.filter(ds => {
                    return (ds.label === "Paredes" || ds.label === "Porta" || ds.label.includes("Montagem")
                        || ds.label.includes("Produ√ß√£o") || ds.label.includes("Armazenamento")
                        || ds.label.includes("Expedi√ß√£o") || ds.label === "MIR" || ds.label === "Caminho MIR");
                });
                const colors = ["red", "blue", "green", "purple", "orange", "brown", "gray"];
                let colorIndex = 0;
                for (let robot_id in robotsData) {
                    const robot = robotsData[robot_id];
                    const color = colors[colorIndex % colors.length];
                    colorIndex++;
                    if (robot.planned_path && robot.planned_path.length > 0) {
                        robotChart.data.datasets.push({
                            label: `${robot_id} (Caminho Futuro)`,
                            data: robot.planned_path.map(p => ({ x: p[0], y: p[1] })),
                            borderColor: color,
                            borderDash: [10, 5],
                            showLine: true,
                            fill: false,
                            borderWidth: 3
                        });
                    }
                    robotChart.data.datasets.push({
                        label: `${robot_id} (Atual)`,
                        data: [{ x: robot.position[0], y: robot.position[1] }],
                        backgroundColor: color,
                        borderColor: "black",
                        borderWidth: 3,
                        pointRadius: 8
                    });
                    if (robot.goal) {
                        robotChart.data.datasets.push({
                            label: `${robot_id} (Destino)`,
                            data: [{ x: robot.goal[0], y: robot.goal[1] }],
                            backgroundColor: "black",
                            borderColor: "black",
                            pointRadius: 6,
                            pointStyle: 'cross'
                        });
                    }
                }
                robotChart.update('none');
                updateInProgress = false;
            }, 500);
        }

        function showAllRobotsDetails() {
            let html = `
        <table class="table table-sm table-bordered">
          <thead class="table-light">
            <tr>
              <th>Rob√¥</th>
              <th>Posi√ß√£o</th>
              <th>Goal</th>
              <th>Tempo Estimado</th>
              <th>Kit</th>
              <th>Miss√£o</th>
            </tr>
          </thead>
          <tbody>
      `;
            const colors = ["red", "blue", "green", "purple", "orange", "brown", "gray"];
            let colorIndex = 0;
            for (let robot_id in robotsData) {
                let r = robotsData[robot_id];
                let currentDelivery = r.current_delivery;
                let missionDesc = "Nenhuma";
                let robotColor = colors[colorIndex % colors.length];
                colorIndex++;
                if (currentDelivery) {
                    missionDesc = `
            <div><strong>Etapa:</strong> ${currentDelivery.stage}</div>
            <div><strong>Pickup:</strong> ${currentDelivery.pickup_area}</div>
            <div><strong>Delivery:</strong> ${currentDelivery.delivery_area}</div>
            <div><strong>Itens:</strong> ${currentDelivery.items ? currentDelivery.items.join(", ") : ""}</div>
          `;
                }
                html += `
          <tr>
            <td style="color: ${robotColor}; font-weight: bold;">${robot_id}</td>
            <td>${r.area}</td>  
            <td>${r.goal ? `${r.goal}` : "Nenhum"}</td>
            <td>${r.estimated_time !== null ? `${r.estimated_time}s` : "Desconhecido"}</td>
            <td>${(r.kit && r.kit.length) ? r.kit.join(", ") : "Vazio"}</td>
            <td>${missionDesc}</td>
          </tr>
        `;
            }
            html += `</tbody></table>`;
            document.getElementById("all_robots_details").innerHTML = html;
        }

        async function addRobot() {
            const button = document.getElementById("add_robot_button");
            button.disabled = true;  // üîπ Evita m√∫ltiplos cliques
            button.textContent = "Adicionando... ‚è≥";

            const nameInput = document.getElementById("robot_name");
            const xInput = document.getElementById("robot_x");
            const yInput = document.getElementById("robot_y");

            const name = nameInput.value.trim();
            const x = parseFloat(xInput.value);
            const y = parseFloat(yInput.value);

            if (!name || isNaN(x) || isNaN(y)) {
                alert("Preencha todos os campos corretamente!");
                button.disabled = false;
                button.textContent = "Adicionar Rob√¥";
                return;
            }

            try {
                // ‚è≥ Executa a requisi√ß√£o em paralelo com a atualiza√ß√£o dos rob√¥s
                const [res] = await Promise.allSettled([
                    axios.post(`${API_URL}/add_robot`, { robot_id: name, x, y }),
                    new Promise(resolve => setTimeout(resolve, 1000)) // Espera antes de atualizar
                ]);

                if (res.status === "fulfilled") {
                    console.log("‚úÖ Rob√¥ adicionado com sucesso:", res.value.data);
                    alert("Rob√¥ adicionado com sucesso!");
                    updateRobots(); // üöÄ Atualiza a lista de rob√¥s

                    // üîπ Resetando os campos
                    nameInput.value = "";
                    xInput.value = "";
                    yInput.value = "";
                } else {
                    console.error("‚ùå Erro ao adicionar rob√¥:", res.reason);
                    alert("Erro ao adicionar rob√¥.");
                }
            } catch (error) {
                console.error("‚ùå Erro ao adicionar rob√¥:", error);
                alert("Erro ao adicionar rob√¥.");
            }

            button.disabled = false; // üîπ Reativa o bot√£o
            button.textContent = "Adicionar Rob√¥";
        }



        function handleDeliveryMission() {
            const robotId = document.getElementById("robot_select").value;
            if (robotId) {
                addDeliveryMission();
            } else {
                requestDeliveryMission();
            }
        }

        async function requestDeliveryMission() {
            const pickupArea = document.getElementById("pickup_select").value;
            const deliveryArea = document.getElementById("delivery_select").value;
            const itemsRaw = document.getElementById("items_text").value;
            const items = itemsRaw.split(",").map(i => i.trim()).filter(i => i.length > 0);
            if (!pickupArea || !deliveryArea || items.length === 0) {
                alert("Por favor, selecione √°rea de pickup, √°rea de entrega e itens.");
                return;
            }
            try {
                const res = await axios.post(`${API_URL}/request_delivery_mission`, { pickup_area: pickupArea, delivery_area: deliveryArea, items });
                alert(res.data.message || "Miss√£o criada!");
                updateRobots();
            } catch (err) {
                console.error("Erro ao solicitar miss√£o de entrega:", err);
            }
        }

        async function addDeliveryMission() {
            const robotId = document.getElementById("robot_select").value;
            const pickupArea = document.getElementById("pickup_select").value;
            const deliveryArea = document.getElementById("delivery_select").value;
            const itemsRaw = document.getElementById("items_text").value;
            const items = itemsRaw.split(",").map(i => i.trim()).filter(i => i.length > 0);
            if (!pickupArea || !deliveryArea || items.length === 0) {
                alert("Por favor, selecione √°rea de pickup, √°rea de entrega e itens.");
                return;
            }
            if (robotsData[robotId] && robotsData[robotId].current_delivery) {
                alert("O rob√¥ selecionado j√° est√° em uma miss√£o!");
                return;
            }
            try {
                const res = await axios.post(`${API_URL}/request_delivery_mission`, { pickup_area: pickupArea, delivery_area: deliveryArea, items });
                alert(res.data.message || "Miss√£o criada!");
                updateRobots();
            } catch (err) {
                console.error("Erro ao solicitar miss√£o de entrega:", err);
            }
        }
        let cellsIndicator = {}; // Ex.: { "Montagem 1-1": "!", "Armazenamento 3-1": "!" }
        let cellsStatus = {};

        async function updateCellsStatus() {
            try {
                const res = await axios.get(`${API_URL}/cells_status`);
                let newCellsStatus = res.data;

                // Verifica se h√° mudan√ßas antes de redesenhar o mapa
                if (JSON.stringify(cellsStatus) !== JSON.stringify(newCellsStatus)) {
                    console.log("Mudan√ßas detectadas no Status dos Postos de trabalho.");
                    cellsStatus = newCellsStatus;
                    drawAreas(areas); // Redesenha apenas se necess√°rio
                }
            } catch (error) {
                console.error("Erro ao buscar Status dos Postos de trabalho:", error);
            }
        }


        async function updateTractorStatus() {
            try {
                const res = await axios.get(`${API_URL}/trator_status`);
                const statusData = res.data;
                areas.forEach(area => {
                    cellsStatus[area.name] = "noPiece";
                });
                if (statusData.tractors) {
                    for (let tractorId in statusData.tractors) {
                        let production = statusData.tractors[tractorId];
                        production.steps.forEach(step => {
                            cellsStatus[step.cell] = production.completed_steps.includes(step.cell) ? "complete" : "pending";
                        });
                    }
                }
                drawAreas(areas);
                updatePiecesStatus();
            } catch (error) {
                console.error("Erro ao buscar status do trator:", error);
            }
        }


        // üîπ Adiciona uma nova etapa sem resetar as existentes
        document.getElementById("add_step").addEventListener("click", () => {
            addStep();
        });

        // üîπ Fun√ß√£o para adicionar um novo passo sem perder os valores anteriores
        function addStep() {
            const container = document.getElementById("production_steps");
            const stepDiv = document.createElement("div");
            stepDiv.className = "production-step row";
            stepDiv.innerHTML = `
        <div class="col-6">
            <select class="cell_select form-control"></select>
        </div>
        <div class="col-4">
            <input type="text" class="kit_input form-control" placeholder="Kits (ex: peca1, peca2)">
        </div>
        <div class="col-2">
            <button class="btn btn-danger remove_step" onclick="removeStep(this)">X</button>
        </div>
    `;
            container.appendChild(stepDiv);
            populateCellSelects(areas); // üîπ Mant√©m as c√©lulas carregadas corretamente
        }

        function removeStep(button) {
            const step = button.parentNode.parentNode;
            step.remove();
        }

        document.getElementById("create_tractor").addEventListener("click", async () => {
            const button = document.getElementById("create_tractor");
            button.disabled = true;  // üîπ Evita m√∫ltiplos cliques
            button.textContent = "Criando... ‚è≥";

            const tractorId = document.getElementById("tractor_id").value.trim();
            if (!tractorId) {
                alert("Informe o nome do trator!");
                resetButton(button, "Criar Trator");
                return;
            }

            // Captura as etapas preenchidas
            const steps = Array.from(document.querySelectorAll(".production-step")).map(div => {
                const cell = div.querySelector(".cell_select").value.trim();
                const kits = div.querySelector(".kit_input").value
                    .split(",")
                    .map(i => i.trim())
                    .filter(i => i.length > 0);
                return cell && kits.length > 0 ? { cell, kits } : null;
            }).filter(Boolean);

            if (steps.length === 0) {
                alert("Adicione pelo menos uma etapa com c√©lula e kits.");
                resetButton(button, "Criar Trator");
                return;
            }

            try {
                const [res] = await Promise.allSettled([
                    axios.post(`${API_URL}/tractor_production`, { tractor_id: tractorId, steps })
                ]);

                if (res.status === "fulfilled") {
                    alert(res.value.data.message || "Trator criado com sucesso!");
                    resetTractorForm(); // üîπ Reseta os campos ap√≥s a cria√ß√£o
                } else {
                    console.error("Erro ao criar trator:", res.reason);
                    alert("Erro ao criar trator.");
                }
            } catch (err) {
                console.error("Erro ao criar trator:", err);
                alert("Erro ao criar trator.");
            }

            resetButton(button, "Criar Trator"); // üîπ Reativa o bot√£o
        });
        // üîπ Reseta os campos do formul√°rio ap√≥s criar o trator
        function resetTractorForm() {
            document.getElementById("tractor_id").value = ""; // Reseta o nome do trator
            document.getElementById("production_steps").innerHTML = ""; // Remove todas as etapas
            addStep(); // Adiciona uma nova etapa vazia automaticamente
        }

        // üîπ Reseta o bot√£o para evitar repeti√ß√£o de c√≥digo
        function resetButton(button, text) {
            button.disabled = false;
            button.textContent = text;
        }

        async function triggerTractorMissions(tractorId) {
            console.log(tractorId)
            if (!tractorId) return;
            try {
                const res = await axios.post(`${API_URL}/trigger_tractor_missions`, { tractor_id: tractorId });
                alert(res.data.message);
                updatePiecesStatus();
            } catch (error) {
                console.error("Erro ao acionar miss√µes:", error);
            }
        }

        async function updatePiecesStatus() {
            try {
                const res = await axios.get(`${API_URL}/pieces_status`);
                const div = document.getElementById("pieces_status");
                let html = "<h5>Status das Pe√ßas</h5><ul>";

                for (const [key, location] of Object.entries(res.data)) {
                    // üö® Convertendo a chave para um formato leg√≠vel
                    let [piece, tractor] = Array.isArray(key) ? key : key.split(",");
                    html += `<li>Pe√ßa: ${piece}, Trator: ${tractor} ‚Üí ${location}</li>`;
                }

                html += "</ul>";
                div.innerHTML = html;
            } catch (error) {
                console.error("Erro ao atualizar status das pe√ßas:", error);
            }
        }



        // Gerenciamento de Tratores - Modal de Edi√ß√£o
        async function openEditTractorModal(tractorId) {
            try {
                const res = await axios.get(`${API_URL}/tractor_production`);
                const tractor = res.data[tractorId];
                if (!tractor) {
                    alert("Trator n√£o encontrado");
                    return;
                }

                document.getElementById("editTractorId").value = tractorId;
                const stepsContainer = document.getElementById("editTractorSteps");
                stepsContainer.innerHTML = "";

                (tractor.steps || []).forEach(step => {
                    const stepDiv = document.createElement("div");
                    stepDiv.className = "edit-step mb-2";
                    stepDiv.innerHTML = `
                <div class="row">
                    <div class="col-5">
                        <select class="form-control cell-select"></select>
                    </div>
                    <div class="col-5">
                        <input type="text" class="form-control kit-input" placeholder="Kits (ex: peca1, peca2)" value="${step.kits ? step.kits.join(", ") : ""}">
                    </div>
                    <div class="col-2">
                        <button type="button" class="btn btn-danger remove-edit-step"><i class="fas fa-times"></i></button>
                    </div>
                </div>
            `;
                    stepsContainer.appendChild(stepDiv);

                    // Popula o select com as op√ß√µes corretas
                    const selectElement = stepDiv.querySelector(".cell-select");
                    populateCellSelectsEdit(selectElement, step.cell);
                    selectElement.value = step.cell; // Mant√©m o valor selecionado corretamente
                });

                // Exibe o modal de edi√ß√£o
                const modalEl = document.getElementById("editTractorModal");
                const modal = new bootstrap.Modal(modalEl);
                modal.show();
            } catch (error) {
                console.error("Erro ao abrir modal de edi√ß√£o:", error);
            }
        }




        document.getElementById("addEditStep").addEventListener("click", function () {
            const stepsContainer = document.getElementById("editTractorSteps");

            const stepDiv = document.createElement("div");
            stepDiv.className = "edit-step mb-2";
            stepDiv.innerHTML = `
        <div class="row">
            <div class="col-5">
                <select class="form-control cell-select"></select>
            </div>
            <div class="col-5">
                <input type="text" class="form-control kit-input" placeholder="Kits (ex: peca1, peca2)">
            </div>
            <div class="col-2">
                <button type="button" class="btn btn-danger remove-edit-step"><i class="fas fa-times"></i></button>
            </div>
        </div>
    `;

            stepsContainer.appendChild(stepDiv);

            // Preenche o select com as c√©lulas dispon√≠veis
            const selectElement = stepDiv.querySelector(".cell-select");
            populateCellSelectsEdit(selectElement);
        });



        document.addEventListener("click", function (e) {
            if (e.target.closest(".remove-edit-step")) {
                e.target.closest(".edit-step").remove();
            }
        });

        document.getElementById("editTractorForm").addEventListener("submit", async function (e) {
            e.preventDefault();
            const tractorId = document.getElementById("editTractorId").value;
            const stepElements = document.querySelectorAll("#editTractorSteps .edit-step");
            const steps = [];
            stepElements.forEach(stepEl => {
                const cell = stepEl.querySelector(".cell-select").value;
                const kitsStr = stepEl.querySelector(".kit-input").value;
                const kits = kitsStr.split(",").map(item => item.trim()).filter(item => item);
                if (cell) {
                    steps.push({ cell, kits });
                }
            });
            try {
                const res = await axios.put(`${API_URL}/tractor_production/${tractorId}`, { tractor_id: tractorId, steps });
                alert(res.data.message);
                updateTractorList();
                const modalEl = document.getElementById("editTractorModal");
                const modalInstance = bootstrap.Modal.getInstance(modalEl);
                modalInstance.hide();
            } catch (error) {
                console.error("Erro ao atualizar trator:", error);
                alert("Erro ao atualizar trator.");
            }
        });

        async function editTractor(tractorId) {
            openEditTractorModal(tractorId);
        }

        function populateCellSelectsEdit(selectElement, selectedValue = "") {
            selectElement.innerHTML = "";
            areas.forEach(area => {
                let optionSelect = document.createElement("option");
                optionSelect.value = area.name;
                optionSelect.textContent = area.name;
                selectElement.appendChild(optionSelect);
            });
        }



        // Atualize a fun√ß√£o updateTractorList para incluir o bot√£o de "Acionar Miss√µes" para cada trator
        async function updateTractorList() {
            try {
                const res = await axios.get(`${API_URL}/tractor_production`);
                const tractorUl = document.getElementById("tractor_ul");
                tractorUl.innerHTML = "";

                for (let tractorId in res.data) {
                    const tractor = res.data[tractorId];
                    let steps = tractor.steps || [];
                    let completed = tractor.completed_steps || [];

                    // Remove as etapas conclu√≠das da lista de etapas
                    steps = steps.filter(step => !completed.includes(step.cell));

                    const formattedSteps = steps.map(step => {
                        const kits = step.kits && step.kits.length ? step.kits.join(", ") : "Sem kits";
                        return `<span class="badge bg-danger me-1">${step.cell} (${kits})</span>`;
                    }).join(" ");

                    const formattedCompleted = completed.map(cell => `<span class="badge bg-success me-1">${cell}</span>`).join(" ");

                    let li = document.createElement("li");
                    li.className = "list-group-item d-flex justify-content-between align-items-center";
                    li.innerHTML = `
                <div>
                  <h5 class="mb-1">${tractorId}</h5>
                  <p class="mb-1"><strong>Etapas:</strong> ${formattedSteps || '<span class="badge bg-warning">Nenhuma</span>'}</p>
                  <p class="mb-0"><strong>Conclu√≠das:</strong> ${formattedCompleted || '<span class="badge bg-warning">Nenhuma</span>'}</p>
                </div>
                <div>
                  <button class="btn btn-sm btn-warning me-2" onclick="triggerTractorMissions('${tractorId}')">
                    <i class="fas fa-play"></i>
                  </button>
                  <button class="btn btn-sm btn-primary me-2" onclick="editTractor('${tractorId}')">
                    <i class="fas fa-edit"></i>
                  </button>
                  <button class="btn btn-sm btn-danger" onclick="deleteTractor('${tractorId}')">
                    <i class="fas fa-trash-alt"></i>
                  </button>
                </div>`;
                    tractorUl.appendChild(li);
                }
            } catch (error) {
                console.error("Erro ao atualizar lista de tratores:", error);
            }
        }

        async function deleteTractor(tractorId) {
            if (confirm("Deseja remover este trator?")) {
                try {
                    const res = await axios.delete(`${API_URL}/tractor_production/${tractorId}`);
                    alert(res.data.message);
                    updateTractorList();
                } catch (error) {
                    console.error("Erro ao remover trator:", error);
                }
            }
        }

        function createArrowCanvas(color, width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d');
            // Desenha uma seta apontando para cima 
            ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(width / 2, 0); // ponta da seta 
            ctx.lineTo(width, height); // canto direito da base
            ctx.lineTo(width / 2, height * 0.7); // meio da base 
            ctx.lineTo(0, height); // canto esquerdo da base
            ctx.closePath(); ctx.fill();
            return canvas;
        }

        // const MAX_PATH_LENGTH = 20; // N√∫mero m√°ximo de pontos vis√≠veis no caminho

        const THRESHOLD = 0.2; // Dist√¢ncia para considerar o ponto percorrido
        let completedPoints = new Set(); // Armazena os pontos percorridos
        let completedPointsMap = new Map(); // Mant√©m estado dos pontos no HTML
        let lastMissionTarget = ""; // Armazena o √∫ltimo destino da miss√£o

        async function updateMir() {
            try {
                const res = await axios.get(`${API_URL}/mir_status`);
                if (res.data && res.data.position) {
                    const mir = res.data;
                    // console.log(mir.position.orientation);

                    // üìå Extrai o nome do destino da miss√£o
                    let missionMatch = mir.mission_text.match(/Moving to '([^']+)'/);
                    let currentMissionTarget = missionMatch ? missionMatch[1] : "";

                    // üìå Se a miss√£o mudou, reseta os pontos percorridos
                    if (currentMissionTarget && currentMissionTarget !== lastMissionTarget) {
                        lastMissionTarget = currentMissionTarget; // Atualiza o destino da miss√£o
                        resetMission(mir.path); // Reseta o caminho
                    }

                    // üìå Atualiza a posi√ß√£o do MIR no gr√°fico
                    let mirDataset = robotChart.data.datasets.find(ds => ds.label === "MIR");
                    if (!mirDataset) {
                        mirDataset = {
                            label: "MIR",
                            data: [{ x: mir.position.x, y: mir.position.y }],
                            pointStyle: createArrowCanvas("magenta", 20, 20),
                            pointRotation: mir.position.orientation,
                            backgroundColor: "magenta",
                            borderColor: "black",
                            borderWidth: 1,
                            pointRadius: 20
                        };
                        robotChart.data.datasets.push(mirDataset);
                    } else {
                        mirDataset.data = [{ x: mir.position.x, y: mir.position.y }];
                        mirDataset.pointRotation = mir.position.orientation;
                    }

                    // üìå Atualiza o caminho do MIR e remove os pontos j√° percorridos
                    if (mir.path && mir.path.length > 0) {
                        let pathDataset = robotChart.data.datasets.find(ds => ds.label === "Caminho MIR");

                        if (!pathDataset) {
                            pathDataset = {
                                label: "Caminho MIR",
                                data: [...mir.path.map(p => ({ x: p.x, y: p.y }))],
                                backgroundColor: "rgba(0, 0, 255, 0.5)", // Azul semitransparente
                                borderColor: "blue",
                                borderWidth: 1,
                                showLine: true,
                                pointRadius: 5
                            };
                            robotChart.data.datasets.push(pathDataset);
                        }

                        // üìå Verifica se o MIR passou por algum ponto do caminho
                        let remainingPoints = [];
                        for (let p of pathDataset.data) {
                            const distance = Math.sqrt(
                                Math.pow(mir.position.x - p.x, 2) + Math.pow(mir.position.y - p.y, 2)
                            );
                            const key = `${p.x.toFixed(2)},${p.y.toFixed(2)}`;

                            if (distance <= THRESHOLD) {
                                completedPoints.add(key); // Adiciona aos pontos percorridos
                                completedPointsMap.set(key, `<span style="color: green;">(${p.x.toFixed(2)}, ${p.y.toFixed(2)})</span>`);
                            } else {
                                remainingPoints.push(p); // Mant√©m no caminho se n√£o foi percorrido
                            }
                        }
                        pathDataset.data = remainingPoints; // Atualiza os pontos restantes no gr√°fico

                        // console.log("Pontos percorridos:", completedPoints);

                        // üìå Atualiza apenas os pontos no HTML sem sobrescrever tudo
                        let htmlPath = mir.path.map(p => {
                            const key = `${p.x.toFixed(2)},${p.y.toFixed(2)}`;
                            return completedPointsMap.get(key) || `(${p.x.toFixed(2)}, ${p.y.toFixed(2)})`;
                        }).join(" ‚ûù ");

                        document.getElementById("mir_path").innerHTML = `<strong>Caminho:</strong> ${htmlPath}`;
                    }

                    // üìå Atualiza o gr√°fico sem anima√ß√£o para evitar piscadas
                    robotChart.update('none');
                    // ‚úÖ Restaurar cor do cabe√ßalho caso esteja vermelho
                    let mirHeader = document.querySelector(".card-header");
                    if (mirHeader) {
                        mirHeader.classList.remove("bg-danger");
                        mirHeader.classList.add("bg-primary");
                    }

                }
                else {
                    // console.log(res.data)
                    // console.log("üî¥ Dados inv√°lidos recebidos:", res.data);
                    setMirOffline();
                }
            } catch (error) {
                console.error("Erro ao atualizar status do MIR:", error);
            }
        }

        function setMirOffline() {
            let mirHeader = document.querySelector(".card-header");
            if (mirHeader) {
                mirHeader.classList.remove("bg-primary");
                mirHeader.classList.add("bg-danger"); // Vermelho
            }

            document.getElementById("mir_name").textContent = "Desligado ou n√£o encontrado";
            document.getElementById("mir_mission").innerHTML = `<strong>Miss√£o:</strong> Sem atividade`;
            document.getElementById("mir_battery").innerHTML = `<strong>Bateria:</strong> N/A`;
            document.getElementById("mir_state").innerHTML = `<strong>Estado:</strong> N/A`;
            document.getElementById("mir_mode").innerHTML = `<strong>Modo:</strong> N/A`;
            document.getElementById("mir_position").innerHTML = `<strong>Posi√ß√£o:</strong> N/A`;
            document.getElementById("mir_orientation").innerHTML = `<strong>Orienta√ß√£o:</strong> N/A`;
            document.getElementById("mir_path").innerHTML = `<strong>Caminho (Hist√≥rico):</strong> Nenhum caminho registrado`;
        }


        // üìå Fun√ß√£o para resetar os pontos quando uma nova miss√£o come√ßar
        function resetMission(newPath) {
            completedPoints.clear(); // Reseta os pontos percorridos

            // Reseta o caminho no gr√°fico
            let pathDataset = robotChart.data.datasets.find(ds => ds.label === "Caminho MIR");
            if (pathDataset) {
                pathDataset.data = newPath.map(p => ({ x: p.x, y: p.y })); // Adiciona os novos pontos
            } else {
                robotChart.data.datasets.push({
                    label: "Caminho MIR",
                    data: newPath.map(p => ({ x: p.x, y: p.y })),
                    backgroundColor: "rgba(0, 0, 255, 0.5)", // Azul semitransparente
                    borderColor: "blue",
                    borderWidth: 2,
                    showLine: true,
                    pointRadius: 5
                });
            }

            // Atualiza o caminho na interface HTML
            document.getElementById("mir_path").innerHTML = `
        <strong>Caminho:</strong> ${newPath.map(p => `(${p.x.toFixed(2)}, ${p.y.toFixed(2)})`).join(" ‚ûù ")}
    `;

            // Atualiza o gr√°fico
            robotChart.update('none');
        }






        async function updateMirStatusPanel() {
            try {
                const res = await axios.get(`${API_URL}/mir_status`);

                if (res.data && res.data.position) {
                    const mir = res.data;

                    // Atualiza os campos com os dados do MIR
                    document.getElementById("mir_name").textContent = mir.robot_name || "MIR";
                    document.getElementById("mir_mission").innerHTML = `<strong>Miss√£o:</strong> ${mir.mission_text || "Sem atividade"}`;
                    document.getElementById("mir_battery").innerHTML = `<strong>Bateria:</strong> ${mir.battery_percentage !== undefined ? mir.battery_percentage + "%" : "N/A"}`;
                    document.getElementById("mir_state").innerHTML = `<strong>Estado:</strong> ${mir.state_text || "N/A"}`;
                    document.getElementById("mir_mode").innerHTML = `<strong>Modo:</strong> ${mir.mode_text || "N/A"}`;

                    // Atualiza posi√ß√£o e orienta√ß√£o
                    const pos = mir.position;
                    document.getElementById("mir_position").innerHTML = `<strong>Posi√ß√£o:</strong> (${pos.x}, ${pos.y})`;
                    document.getElementById("mir_orientation").innerHTML = `<strong>Orienta√ß√£o:</strong> ${pos.orientation !== undefined ? pos.orientation.toFixed(2) + "¬∞" : "N/A"}`;

                    // ‚úÖ Se a requisi√ß√£o foi bem-sucedida, restaurar a cor azul do cabe√ßalho
                    let mirHeader = document.querySelector(".card-header");
                    if (mirHeader) {
                        mirHeader.classList.remove("bg-danger");
                        mirHeader.classList.add("bg-primary");
                    }
                } else {
                    setMirOffline(); // Caso os dados retornem vazios, definir como offline
                }
            } catch (error) {
                console.error("Erro ao atualizar status do MIR:", error);
                setMirOffline(); // Define como offline ao capturar erro na requisi√ß√£o
            }
        }

        // setInterval(updateCellsStatus, 5000);

        let tempoRealAtivo = true;
        let intervalosAtivos = [];
        async function atualizarTudo() {
            console.log("üîÑ Atualizando status de todos os componentes...");

            const tasks = [
                // updateRobots(),
                updateTractorStatus(),
                updateMirStatusPanel(),
                updateTractorList(),
                updatePiecesStatus(),
                updateCellsStatus(),
                atualizarHistoricoEstados()
            ];

            await Promise.allSettled(tasks);

            console.log("‚úÖ Atualiza√ß√£o conclu√≠da.");
        }

        // Inicia o loop de atualiza√ß√£o a cada 3 segundos
        // let intervaloAtualizacao = setInterval(atualizarTudo, 3000);

        function ativarTempoReal() {
            tempoRealAtivo = true;
            document.getElementById("btnTempoReal").classList.remove("btn-secondary");
            document.getElementById("btnTempoReal").classList.add("btn-success");
            document.getElementById("btnTempoReal").innerText = "üîÑ Tempo Real";

            // Para qualquer atualiza√ß√£o anterior
            pararTodosOsUpdates();
            atualizarTudo()
            // üîÑ Atualiza imediatamente ao ativar
            // updateRobots();
            // updateTractorStatus();
            // updateMirStatusPanel();
            // updateTractorList();
            // updatePiecesStatus();

            // üîÑ Inicia os intervalos para atualiza√ß√µes cont√≠nuas
            intervalosAtivos.push(setInterval(updateRobots, 500));
            // intervalosAtivos.push(setInterval(updateTractorStatus, 500));
            // intervalosAtivos.push(setInterval(updateMirStatusPanel, 3000));
            // intervalosAtivos.push(setInterval(updateTractorList, 5000));
            // intervalosAtivos.push(setInterval(updatePiecesStatus, 5000));
            // intervalosAtivos.push(setInterval(updateCellsStatus, 5000));
            // intervalosAtivos.push(setInterval(atualizarHistoricoEstados, 10000));
            // üîÑ Inicia um √∫nico intervalo para atualizar tudo a cada 3 segundos
            // intervalosAtivos.push(setInterval(() => {
            //     updateRobots();
            //     updateTractorStatus();
            //     updateMirStatusPanel();
            //     updateTractorList();
            //     updatePiecesStatus();
            //     updateCellsStatus();
            //     atualizarHistoricoEstados();
            // }, 3000));

            intervalosAtivos.push(setInterval(() => {
                atualizarTudo()
            }, 10000))




        }

        function desativarTempoReal() {
            tempoRealAtivo = false;
            pararTodosOsUpdates();

            document.getElementById("btnTempoReal").classList.remove("btn-success");
            document.getElementById("btnTempoReal").classList.add("btn-secondary");
            document.getElementById("btnTempoReal").innerText = "‚è≥ Tempo Real Pausado";
        }

        // Para todos os intervalos ativos
        function pararTodosOsUpdates() {
            intervalosAtivos.forEach(clearInterval);
            intervalosAtivos = [];
        }

        // Alterna entre Tempo Real e Hist√≥rico
        document.getElementById("btnTempoReal").addEventListener("click", function () {
            if (tempoRealAtivo) {
                desativarTempoReal();
            } else {
                ativarTempoReal();
            }
        });

        // Ajuste para parar atualiza√ß√µes autom√°ticas ao carregar o hist√≥rico
        document.getElementById("btnCarregarHistorico").addEventListener("click", function () {
            desativarTempoReal();
            carregarHistorico();
        });


        // Inicia a aplica√ß√£o com tempo real ativado
        async function start() {
            createChart();
            await loadMapData();
            ativarTempoReal();
        }

        start();

    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.1.3/js/bootstrap.bundle.min.js"></script>
    <script>
        let historico = [];       // para armazenar os snapshots
        let playing = false;      // para controlar se est√° em 'play'
        let playInterval = null;  // para o setInterval

        async function carregarHistorico() {
            try {
                const resp = await axios.get(`${API_URL}/historico`);
                historico = resp.data.historico;
                console.log("Hist√≥rico carregado:", historico);

                // Ajusta o slider
                document.getElementById("timelineSlider").max = historico.length - 1;
                document.getElementById("timelineSlider").value = 0;
                document.getElementById("sliderValue").innerText = "0";

                desenharFrame(0);  // üîπ Exibe o primeiro frame ao carregar
            } catch (err) {
                console.error("Erro ao carregar hist√≥rico:", err);
            }
        }

        // Adiciona evento no bot√£o


        async function desenharFrame(frameIndex) {
            if (!historico[frameIndex]) return;
            const snapshot = historico[frameIndex];

            console.log("üîÑ Carregando frame:", frameIndex);
            console.log(snapshot)
            // console.log("üìå √Åreas carregadas do hist√≥rico:", snapshot.cells);

            // üîπ Convertendo √°reas do formato array para objeto
            let convertedAreas = snapshot.cells.map(area => ({
                x1: area[0],
                y1: area[1],
                x2: area[2],
                y2: area[3],
                name: area[4]
            }));
            cellsStatusTmp = snapshot.cells_status
            // console.log("üìå √Åreas convertidas:", convertedAreas);


            // üîπ Limpa os dados do gr√°fico antes de redesenhar
            robotChart.data.datasets = [];

            // üîπ Redesenha as √°reas e portas
            drawAreasHistorico(convertedAreas, cellsStatusTmp);
            drawDoors(snapshot.doors || []);

            // // üîπ Redesenha as paredes (WALLS)
            // if (snapshot.walls.length > 0) {
            //     robotChart.data.datasets.push({
            //         label: "Paredes",
            //         data: snapshot.walls.map(wall => ({ x: wall[0], y: wall[1] })), // üîÑ Converte para formato do Chart.js
            //         backgroundColor: "black",
            //         borderColor: "black",
            //         borderWidth: 2,
            //         pointRadius: 4
            //     });
            // }

            // üîπ Redesenha os rob√¥s e seus caminhos planejados
            Object.entries(snapshot.robots).forEach(([robotId, robData], idx) => {
                const color = ["red", "blue", "green", "orange", "purple"][idx % 5];

                if (robData.planned_path && robData.planned_path.length > 0) {
                    robotChart.data.datasets.push({
                        label: `${robotId} (Caminho)`,
                        data: robData.planned_path.map(p => ({ x: p[0], y: p[1] })),
                        borderColor: color,
                        borderDash: [10, 5],
                        showLine: true,
                        fill: false,
                        borderWidth: 3
                    });
                }

                robotChart.data.datasets.push({
                    label: `${robotId} (Atual)`,
                    data: [{ x: robData.position[0], y: robData.position[1] }],
                    backgroundColor: color,
                    pointRadius: 8
                });

                if (robData.goal) {
                    robotChart.data.datasets.push({
                        label: `${robotId} (Destino)`,
                        data: [{ x: robData.goal[0], y: robData.goal[1] }],
                        backgroundColor: "black",
                        borderColor: "black",
                        pointRadius: 6,
                        pointStyle: 'cross'
                    });
                }
            });

            // üîπ Desenhar o MiR, se existir no snapshot e n√£o estiver offline
            if (snapshot.mir && snapshot.mir.position && !isMirDataEmpty(snapshot.mir)) {
                const mirData = snapshot.mir;

                // 2.1) Desenhar posi√ß√£o atual
                robotChart.data.datasets.push({
                    label: "MIR (Hist√≥rico)",
                    data: [{ x: mirData.position.x, y: mirData.position.y }],
                    pointStyle: createArrowCanvas("magenta", 20, 20),
                    pointRotation: mirData.position.orientation,
                    backgroundColor: "magenta",
                    borderColor: "black",
                    borderWidth: 1,
                    pointRadius: 20
                });

                // 2.2) Desenhar o path, se existir
                if (mirData.path && mirData.path.length > 0) {
                    robotChart.data.datasets.push({
                        label: "Caminho MIR (Hist√≥rico)",
                        data: mirData.path.map(p => ({ x: p.x, y: p.y })),
                        backgroundColor: "rgba(0, 0, 255, 0.2)",
                        borderColor: "blue",
                        showLine: true,
                        fill: false,
                        pointRadius: 5,
                        borderWidth: 2
                    });
                }

                // 2.3) Atualizar painel textual (se quiser exibir miss√£o, etc.)
                updateMirPanel(snapshot.mir);
            }




            robotChart.update();

            const ts = new Date(snapshot.timestamp * 1000).toLocaleString();
            document.getElementById("sliderValue").innerText = `${frameIndex} / T=${ts}`;
        }






        // 4) EVENTOS DO SLIDER
        document.getElementById("timelineSlider").addEventListener("input", function (e) {
            const frameIndex = parseInt(e.target.value);
            desenharFrame(frameIndex);
        });

        // 5) BOT√ïES DE PLAY E PAUSE
        function play() {
            if (playing || historico.length === 0) return;
            playing = true;
            playInterval = setInterval(() => {
                let slider = document.getElementById("timelineSlider");
                let val = parseInt(slider.value);
                if (val < historico.length - 1) {
                    slider.value = val + 1;
                    desenharFrame(val + 1);
                } else {
                    // chegamos no final
                    pause();
                }
            }, 1000); // avan√ßa 1 frame/segundo (ajuste a gosto)
        }

        function pause() {
            if (!playing) return;
            clearInterval(playInterval);
            playing = false;
        }

        function isMirDataEmpty(mir) {
            return !mir.robot_name &&
                !mir.mission_text &&
                mir.battery_percentage === null &&
                !mir.state_text &&
                !mir.mode_text &&
                (!mir.position || (mir.position.x === 0 && mir.position.y === 0 && mir.position.orientation === 0)) &&
                (!mir.path || mir.path.length === 0);
        }

        function updateMirPanel(mir) {
            console.log(mir);

            let mirHeader = document.querySelector(".card-header");

            // Se n√£o h√° dados ou est√° "desligado", definir como offline
            if (isMirDataEmpty(mir)) {
                setMirOffline();
                return;
            }

            // Se o rob√¥ est√° ativo, restaurar a cor azul do cabe√ßalho
            if (mirHeader) {
                mirHeader.classList.remove("bg-danger");
                mirHeader.classList.add("bg-primary");
            }

            // Atualiza os dados do MiR
            document.getElementById("mir_name").textContent = mir.robot_name ? `${mir.robot_name} (Hist√≥rico)` : "MIR";
            document.getElementById("mir_mission").innerHTML = `<strong>Miss√£o:</strong> ${mir.mission_text || "Sem atividade"}`;
            document.getElementById("mir_battery").innerHTML = `<strong>Bateria:</strong> ${mir.battery_percentage !== null ? mir.battery_percentage + "%" : "N/A"}`;
            document.getElementById("mir_state").innerHTML = `<strong>Estado:</strong> ${mir.state_text || "N/A"}`;
            document.getElementById("mir_mode").innerHTML = `<strong>Modo:</strong> ${mir.mode_text || "N/A"}`;

            // Atualiza posi√ß√£o e orienta√ß√£o
            const pos = mir.position;
            document.getElementById("mir_position").innerHTML = `<strong>Posi√ß√£o:</strong> ${pos && (pos.x !== 0 || pos.y !== 0) ? `(${pos.x}, ${pos.y})` : "N/A"}`;
            document.getElementById("mir_orientation").innerHTML = `<strong>Orienta√ß√£o:</strong> ${pos && pos.orientation !== 0 ? pos.orientation.toFixed(2) + "¬∞" : "N/A"}`;

            // Atualiza caminho do MiR
            if (document.getElementById("mir_path")) {
                if (Array.isArray(mir.path) && mir.path.length > 0) {
                    const pathStr = mir.path
                        .map(pt => `(${pt.x.toFixed(2)}, ${pt.y.toFixed(2)})`)
                        .join(" ‚ûù ");
                    document.getElementById("mir_path").innerHTML = `<strong>Caminho (Hist√≥rico):</strong> ${pathStr}`;
                } else {
                    document.getElementById("mir_path").innerHTML = `<strong>Caminho (Hist√≥rico):</strong> Nenhum caminho registrado`;
                    console.warn("‚ö†Ô∏è mir.path est√° indefinido, vazio ou n√£o √© um array.");
                }
            }
        }





        let charts = {}; // Armazena as inst√¢ncias dos gr√°ficos
        let historicoData = []; // Armazena os registros ao longo do tempo
        let timestamps = []; // Mant√©m os momentos em que os dados foram coletados

        async function atualizarHistoricoEstados() {
            try {
                const response = await fetch("http://127.0.0.1:8000/historico_estados");
                const data = await response.json();
                console.log("üì° Dados recebidos:", data);  // ‚úÖ Log para depura√ß√£o

                if (!data || typeof data !== "object") {
                    throw new Error("Resposta inv√°lida do servidor");
                }

                // Verifica se as chaves existem antes de atualizar os gr√°ficos
                if (!data.celulas || !Array.isArray(data.celulas)) {
                    console.warn("‚ö†Ô∏è Dados de c√©lulas ausentes ou inv√°lidos");
                    data.celulas = [];
                }
                if (!data.robos || !Array.isArray(data.robos)) {
                    console.warn("‚ö†Ô∏è Dados de rob√¥s ausentes ou inv√°lidos");
                    data.robos = [];
                }
                if (!data.tratores || !Array.isArray(data.tratores)) {
                    console.warn("‚ö†Ô∏è Dados de tratores ausentes ou inv√°lidos");
                    data.tratores = [];
                }

                const timestamp = new Date().toLocaleTimeString();
                timestamps.push(timestamp);
                historicoData.push(data);

                if (historicoData.length > 20) {
                    historicoData.shift();
                    timestamps.shift();
                }

                gerarGraficoGeral("graficoCelulasGeral", data.celulas, "C√©lulas - Evolu√ß√£o por Estado");
                gerarGraficoGeral("graficoRobosGeral", data.robos, "Rob√¥s - Evolu√ß√£o por Estado");
                gerarGraficoGeral("graficoTratoresGeral", data.tratores, "Tratores - Evolu√ß√£o por Estado");

            } catch (error) {
                console.error("Erro ao buscar hist√≥rico de estados:", error);
            }
        }


        function gerarGraficoGeral(canvasId, objetos, titulo) {
            const ctx = document.getElementById(canvasId).getContext("2d");

            if (charts[canvasId]) {
                charts[canvasId].destroy();
            }

            const estadosUnicos = [...new Set(Object.values(objetos).flatMap(obj => Object.keys(obj)))];

            let datasetMap = {};
            estadosUnicos.forEach(estado => datasetMap[estado] = new Array(timestamps.length).fill(0));

            historicoData.forEach((registro, index) => {
                for (const tempos of Object.values(registro[canvasId.includes("Celulas") ? "celulas" : canvasId.includes("Robos") ? "robos" : "tratores"])) {
                    for (const [estado, tempo] of Object.entries(tempos)) {
                        datasetMap[estado][index] = tempo; // Atribuir diretamente ao inv√©s de somar
                    }
                }
            });


            // Converte para porcentagem
            for (let i = 0; i < timestamps.length; i++) {
                let totalTempo = Object.values(datasetMap).reduce((acc, val) => acc + val[i], 0);
                if (totalTempo > 0) {
                    for (const estado in datasetMap) {
                        datasetMap[estado][i] = (datasetMap[estado][i] / totalTempo) * 100;
                    }
                }
            }

            const datasets = Object.keys(datasetMap).map((estado) => ({
                label: estado,
                backgroundColor: getColorForState(estado),
                borderColor: getColorForState(estado),
                data: datasetMap[estado],
                fill: 'start',
                tension: 0
            }));

            charts[canvasId] = new Chart(ctx, {
                type: "line",
                data: { labels: timestamps, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { title: { display: true, text: titulo } },
                    scales: {
                        x: { stacked: true },
                        y: { stacked: true, min: 0, max: 100 } // Mant√©m sempre de 0 a 100%
                    }
                }
            });
        }
        function getColorForState(status) {
            const colors = {
                // Cores das c√©lulas no mapa
                "complete": "green",    // Verde para c√©lulas completas
                "pending": "red",       // Vermelho para c√©lulas pendentes
                "noPiece": "yellow",    // Amarelo para c√©lulas sem pe√ßa

                // Cores dos rob√¥s baseados na miss√£o
                "coletando": "brown",    // Cinza para quando o rob√¥ est√° coletando pe√ßas
                "entregando": "blue",   // Azul para quando o rob√¥ est√° entregando pe√ßas
                "movendo": "purple",    // Roxo para quando o rob√¥ est√° em deslocamento sem miss√£o ativa
                "parado": "orange",     // Laranja para quando o rob√¥ est√° parado

                // Cores dos tratores
                "produzindo": "green",  // Verde para tratores produzindo
                "esperando": "red"   // Amarelo para tratores esperando
            };
            return colors[status] || "gray"; // Cor padr√£o caso o status n√£o seja reconhecido
        }




        // 6) LISTENERS
        document.getElementById("btnPlay").addEventListener("click", play);
        document.getElementById("btnPause").addEventListener("click", pause);
    </script>
</body>

</html>